"""
Core experiment models for the autonomous multi‑agent runner.

These models are consumed by:
- ``self-improvement/santiago-pm/tackle/experiments/experiment_runner.py``
- ``self-improvement/santiago-pm/quality-assessments/test_experiment_runner.py``
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional


@dataclass
class ExperimentPhase:
    """
    A single phase within a multi‑day autonomous experiment.

    The default configuration generated by the experiment runner uses at
    least ``name`` and ``duration_days``; additional attributes can be
    added later without breaking callers that only rely on these fields.
    """

    name: str
    duration_days: int
    description: str = ""
    objectives: List[str] = field(default_factory=list)


@dataclass
class Decision:
    """
    A decision that may be resolved autonomously or queued for a human.

    Tests construct this type with::

        Decision(
            id=\"test_decision\",
            title=\"Test Decision\",
            context=\"Test context\",
            options=[\"Option A\", \"Option B\"],
            priority=\"high\",
        )
    """

    id: str
    title: str
    context: str
    options: List[str]
    priority: str = "medium"
    created_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class DecisionQueue:
    """
    Simple in‑memory queue for experiment decisions.

    The autonomous runner uses this to accumulate decisions that require
    human input or delayed resolution.
    """

    items: List[Decision] = field(default_factory=list)

    def enqueue(self, decision: Decision) -> None:
        """Add a new decision to the tail of the queue."""
        self.items.append(decision)

    def dequeue(self) -> Optional[Decision]:
        """Remove and return the next decision, or ``None`` if empty."""
        if not self.items:
            return None
        return self.items.pop(0)

    def __len__(self) -> int:  # pragma: no cover - trivial
        return len(self.items)


@dataclass
class ExperimentConfig:
    """
    High‑level configuration for an autonomous experiment.

    The quality assessment tests construct this with:

        ExperimentConfig(
            experiment_name=\"test-experiment\",
            duration_days=1,
            phases=[],
            decision_triggers=[],
            success_criteria={},
        )
    """

    experiment_name: str
    duration_days: int
    phases: List[ExperimentPhase] = field(default_factory=list)
    decision_triggers: List[Dict[str, Any]] = field(default_factory=list)
    success_criteria: Dict[str, Any] = field(default_factory=dict)


"""
Experiment Models

Data models for autonomous experiment execution.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Any, Optional
from enum import Enum


class ExperimentPhaseType(Enum):
    BOOTSTRAPPING = "bootstrapping"
    KNOWLEDGE_LOADING = "knowledge_loading"
    AUTONOMOUS_DEVELOPMENT = "autonomous_development"
    SELF_EVALUATION = "self_evaluation"


@dataclass
class ExperimentPhase:
    """Represents a phase in the experiment."""
    name: str
    duration_days: int
    behaviors: List[str]
    success_metrics: List[str]


@dataclass
class ExperimentConfig:
    """Configuration for an autonomous experiment."""
    experiment_name: str
    duration_days: int
    phases: List[ExperimentPhase]
    decision_triggers: List[str] = field(default_factory=list)
    success_criteria: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Decision:
    """A decision that requires resolution."""
    id: str
    title: str
    context: str
    options: List[str]
    priority: str = "medium"
    timestamp: Optional[datetime] = None
    resolved: bool = False
    resolution: Optional[str] = None


class DecisionQueue:
    """Queue for managing decisions that require resolution."""

    def __init__(self):
        self.decisions: List[Decision] = []

    def add_decision(self, decision: Decision):
        """Add a decision to the queue."""
        self.decisions.append(decision)

    def get_pending_decisions(self) -> List[Decision]:
        """Get all pending (unresolved) decisions."""
        return [d for d in self.decisions if not d.resolved]

    def has_pending_decisions(self) -> bool:
        """Check if there are pending decisions."""
        return len(self.get_pending_decisions()) > 0

    def resolve_decision(self, decision_id: str, resolution: str):
        """Resolve a decision with the given resolution."""
        for decision in self.decisions:
            if decision.id == decision_id:
                decision.resolved = True
                decision.resolution = resolution
                break

    def get_decision(self, decision_id: str) -> Optional[Decision]:
        """Get a decision by ID."""
        for decision in self.decisions:
            if decision.id == decision_id:
                return decision
        return None